/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the
 * LICENSE file in the root directory of this source tree.
 **/

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_COARSECONVFEATURIZERUNITS_FFBS_H_
#define FLATBUFFERS_GENERATED_COARSECONVFEATURIZERUNITS_FFBS_H_

#include "flatbuffers/flatbuffers.h"

namespace ffbs {

struct UnitType;

struct ReducedUnitTypes;
struct ReducedUnitTypesT;

MANUALLY_ALIGNED_STRUCT(4) UnitType FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t id_;
  int32_t x_;
  int32_t y_;
  int32_t type_;
  int32_t visible_;

 public:
  UnitType() { memset(this, 0, sizeof(UnitType)); }
  UnitType(const UnitType &_o) { memcpy(this, &_o, sizeof(UnitType)); }
  UnitType(int32_t _id, int32_t _x, int32_t _y, int32_t _type, int32_t _visible)
    : id_(flatbuffers::EndianScalar(_id)), x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), type_(flatbuffers::EndianScalar(_type)), visible_(flatbuffers::EndianScalar(_visible)) { }

  int32_t id() const { return flatbuffers::EndianScalar(id_); }
  int32_t x() const { return flatbuffers::EndianScalar(x_); }
  int32_t y() const { return flatbuffers::EndianScalar(y_); }
  int32_t type() const { return flatbuffers::EndianScalar(type_); }
  int32_t visible() const { return flatbuffers::EndianScalar(visible_); }
};
STRUCT_END(UnitType, 20);

struct ReducedUnitTypesT : public flatbuffers::NativeTable {
  typedef ReducedUnitTypes TableType;
  int8_t version;
  std::vector<UnitType> units_p0;
  std::vector<UnitType> units_p1;
  std::vector<UnitType> units_n;
  ReducedUnitTypesT()
    : version(0) {}
};

struct ReducedUnitTypes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReducedUnitTypesT NativeTableType;
  enum {
    VT_VERSION = 4,
    VT_UNITS_P0 = 6,
    VT_UNITS_P1 = 8,
    VT_UNITS_N = 10
  };
  int8_t version() const { return GetField<int8_t>(VT_VERSION, 0); }
  const flatbuffers::Vector<const UnitType *> *units_p0() const { return GetPointer<const flatbuffers::Vector<const UnitType *> *>(VT_UNITS_P0); }
  const flatbuffers::Vector<const UnitType *> *units_p1() const { return GetPointer<const flatbuffers::Vector<const UnitType *> *>(VT_UNITS_P1); }
  const flatbuffers::Vector<const UnitType *> *units_n() const { return GetPointer<const flatbuffers::Vector<const UnitType *> *>(VT_UNITS_N); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNITS_P0) &&
           verifier.Verify(units_p0()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNITS_P1) &&
           verifier.Verify(units_p1()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UNITS_N) &&
           verifier.Verify(units_n()) &&
           verifier.EndTable();
  }
  ReducedUnitTypesT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<ReducedUnitTypes> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducedUnitTypesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReducedUnitTypesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(int8_t version) { fbb_.AddElement<int8_t>(ReducedUnitTypes::VT_VERSION, version, 0); }
  void add_units_p0(flatbuffers::Offset<flatbuffers::Vector<const UnitType *>> units_p0) { fbb_.AddOffset(ReducedUnitTypes::VT_UNITS_P0, units_p0); }
  void add_units_p1(flatbuffers::Offset<flatbuffers::Vector<const UnitType *>> units_p1) { fbb_.AddOffset(ReducedUnitTypes::VT_UNITS_P1, units_p1); }
  void add_units_n(flatbuffers::Offset<flatbuffers::Vector<const UnitType *>> units_n) { fbb_.AddOffset(ReducedUnitTypes::VT_UNITS_N, units_n); }
  ReducedUnitTypesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ReducedUnitTypesBuilder &operator=(const ReducedUnitTypesBuilder &);
  flatbuffers::Offset<ReducedUnitTypes> Finish() {
    auto o = flatbuffers::Offset<ReducedUnitTypes>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<ReducedUnitTypes> CreateReducedUnitTypes(flatbuffers::FlatBufferBuilder &_fbb,
    int8_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<const UnitType *>> units_p0 = 0,
    flatbuffers::Offset<flatbuffers::Vector<const UnitType *>> units_p1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<const UnitType *>> units_n = 0) {
  ReducedUnitTypesBuilder builder_(_fbb);
  builder_.add_units_n(units_n);
  builder_.add_units_p1(units_p1);
  builder_.add_units_p0(units_p0);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReducedUnitTypes> CreateReducedUnitTypesDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int8_t version = 0,
    const std::vector<const UnitType *> *units_p0 = nullptr,
    const std::vector<const UnitType *> *units_p1 = nullptr,
    const std::vector<const UnitType *> *units_n = nullptr) {
  return CreateReducedUnitTypes(_fbb, version, units_p0 ? _fbb.CreateVector<const UnitType *>(*units_p0) : 0, units_p1 ? _fbb.CreateVector<const UnitType *>(*units_p1) : 0, units_n ? _fbb.CreateVector<const UnitType *>(*units_n) : 0);
}

inline flatbuffers::Offset<ReducedUnitTypes> CreateReducedUnitTypes(flatbuffers::FlatBufferBuilder &_fbb, const ReducedUnitTypesT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

inline ReducedUnitTypesT *ReducedUnitTypes::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new ReducedUnitTypesT();
  { auto _e = version(); _o->version = _e; };
  { auto _e = units_p0(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->units_p0.push_back(*_e->Get(_i)); } } };
  { auto _e = units_p1(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->units_p1.push_back(*_e->Get(_i)); } } };
  { auto _e = units_n(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->units_n.push_back(*_e->Get(_i)); } } };
  return _o;
}

inline flatbuffers::Offset<ReducedUnitTypes> ReducedUnitTypes::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReducedUnitTypesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReducedUnitTypes(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReducedUnitTypes> CreateReducedUnitTypes(flatbuffers::FlatBufferBuilder &_fbb, const ReducedUnitTypesT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateReducedUnitTypes(_fbb,
    _o->version,
    _o->units_p0.size() ? _fbb.CreateVectorOfStructs(_o->units_p0) : 0,
    _o->units_p1.size() ? _fbb.CreateVectorOfStructs(_o->units_p1) : 0,
    _o->units_n.size() ? _fbb.CreateVectorOfStructs(_o->units_n) : 0);
}

inline const ffbs::ReducedUnitTypes *GetReducedUnitTypes(const void *buf) {
  return flatbuffers::GetRoot<ffbs::ReducedUnitTypes>(buf);
}

inline bool VerifyReducedUnitTypesBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ffbs::ReducedUnitTypes>(nullptr);
}

inline void FinishReducedUnitTypesBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<ffbs::ReducedUnitTypes> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<ReducedUnitTypesT> UnPackReducedUnitTypes(const void *buf, const flatbuffers::resolver_function_t *resolver = nullptr) {
  return std::unique_ptr<ReducedUnitTypesT>(GetReducedUnitTypes(buf)->UnPack(resolver));
}

}  // namespace ffbs

#endif  // FLATBUFFERS_GENERATED_COARSECONVFEATURIZERUNITS_FFBS_H_
